1.冒泡算法  稳定
  平均O(n^2)	最差O(n^2)	最好O(n)
  
  1.从头部开始，两两比较（无序部分所有元素都要比较）；
  2.将较大的放到尾部，成为有序部分；
  3.继续这一过程，直到全部有序。
  for(i=0;i<n;i++)
	for(j=0;j<n-i;j++)
		if(num[j]>num[j+1])
			swap(num[j],num[j+1]);
			
2.快速排序
  平均O(nlog2(n))	最差O(n^2)	最好O(n)
  【游标思想】
  1.以第一个数为基准k，i=0，j=n-1
  2.1 从j开始，从右向左找小于基准k的数，交换(num)